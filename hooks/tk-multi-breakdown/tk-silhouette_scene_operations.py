# Copyright (c) 2013 Shotgun Software Inc.
#
# CONFIDENTIAL AND PROPRIETARY
#
# This work is provided "AS IS" and subject to the Shotgun Pipeline Toolkit
# Source Code License included in this distribution package. See LICENSE.
# By accessing, using, copying or modifying this work you indicate your
# agreement to the Shotgun Pipeline Toolkit Source Code License. All rights
# not expressly granted therein are reserved by Shotgun Software Inc.

import os
import fx

import sgtk

HookBaseClass = sgtk.get_hook_baseclass()


class BreakdownSceneOperations(HookBaseClass):
    """
    Breakdown operations for silhouette.

    This implementation handles detection of 3de camera footage.
    """

    def scan_scene(self):
        """
        The scan scene method is executed once at startup and its purpose is
        to analyze the current scene and return a list of references that are
        to be potentially operated on.

        The return data structure is a list of dictionaries. Each scene reference
        that is returned should be represented by a dictionary with three keys:

        - "node": The name of the 'node' that is to be operated on. Most DCCs have
          a concept of a node, path or some other way to address a particular
          object in the scene.
        - "type": The object type that this is. This is later passed to the
          update method so that it knows how to handle the object.
        - "path": Path on disk to the referenced object.

        Toolkit will scan the list of items, see if any of the objects matches
        any templates and try to determine if there is a more recent version
        available. Any such versions are then displayed in the UI as out of date.

        """
        reads = []

        project = fx.activeProject()
        # find source items in project
        for item in project.items:
            if isinstance(item, fx.SourceItem):
                source = item.source
                # label is human readable, but only id is unique
                reads.append({"node": (source.label, item.id),
                              "type": "source",
                              "path": source.property("path").value})

        return reads

    def update(self, items):
        """
        Perform replacements given a number of scene items passed from the app.

        Once a selection has been performed in the main UI and the user clicks
        the update button, this method is called.

        The items parameter is a list of dictionaries on the same form as was
        generated by the scan_scene hook above. The path key now holds
        the that each node should be updated *to* rather than the current path.
        """
        engine = self.parent.engine

        # TODO: is there a way to find input nodes from source/source_item?
        project = fx.activeProject()
        source_node_mapping = {}
        for session in project.sessions:
            for node in session.inputs:
                source_id = node.property("stream.primary").value.id
                node_list = source_node_mapping.setdefault(source_id, [])
                node_list.append(node)

        for i in items:
            node_id = i["node"]
            node_type = i["type"]
            new_path = i["path"]

            if node_type == "source":
                source_label, source_item_id = node_id
                engine.log_debug("Path for source %s: Updating to version %s" % (source_label, new_path))

                # update source.property("path")
                source_item = fx.findObject(source_item_id)
                path_property = source_item.source.property("path")
                formatted_path, errors = engine.utils.seq_path_to_silhouette_format(self.sgtk, new_path)
                if errors:
                    engine.utils.warn_with_pop_up(self.parent.logger, "Image path used as is", errors)
                path_property.setValue(formatted_path)

                # update source and node labels.
                # TODO: does silhouette ever have anything in the trailing brackets?
                label = os.path.basename(formatted_path) + " []"

                # TODO: the display doesn't auto-refresh
                source_item.label = label
                for node in source_node_mapping[source_item.source.id]:
                    node.label = label
